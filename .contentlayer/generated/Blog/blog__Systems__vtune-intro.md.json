{
  "title": "Vtune Usage",
  "date": "2022-11-21T00:00:00.000Z",
  "tags": [
    "profiling",
    "Intel",
    "VTune"
  ],
  "draft": false,
  "summary": "Instructions Retired per Cycle, or IPC shows average number of retired instructions per cycle. Modern superscalar processors issue up to four instruct",
  "authors": [
    "default"
  ],
  "body": {
    "raw": "\n## 前言\n\n最近在研究vtune，试着用其进行代码性能的分析，主要看了snapshot和hotspot两个analysis type。\n\nvtune的安装可以使用官方的docker，或者[自己安装oneAPI](https://www.intel.com/content/www/us/en/develop/documentation/installation-guide-for-intel-oneapi-toolkits-linux/top.html)。我使用的是[apt install](https://www.intel.com/content/www/us/en/develop/documentation/installation-guide-for-intel-oneapi-toolkits-linux/top/installation/install-using-package-managers/apt.html)，脚本如下。\n\n\n```bash\napt-get install -y --no-install-recommends curl ca-certificates gpg-agent software-properties-common\n\n# download the key to system keyring\nwget -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB | gpg --dearmor | tee /usr/share/keyrings/oneapi-archive-keyring.gpg > /dev/null\n\n# add signed entry to apt sources and configure the APT client to use Intel repository:\necho \"deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] https://apt.repos.intel.com/oneapi all main\" | tee /etc/apt/sources.list.d/oneAPI.list\n\n# install base kit and hpc kit\napt update && apt install intel-basekit intel-hpckit -y\n\n# source vtune env\necho \"source /opt/intel/oneapi/vtune/latest/vtune-vars.sh\" >> ~/.bashrc\n```\n\n## 用法\n\n因为代码运行往往在远程服务器上，一般来说是没有GUI的，因此我们采取的方式是在远端我们使用CLI进行分析，将分析结果在本地机器上可视化。\n\n命令可以用`vtune -h`查看：\n\n```bash\n#  1) Start with a performance snapshot. Get a quick overview of potential performance issues. Identify next steps for a deeper analysis:\nvtune -collect performance-snapshot a.out\n \n#  2) Run a hotspots collection (in user-mode sampling) on the specified target:\nvtune -collect hotspots a.out\n```\n\n### Performance Snapshot\n\n\nIPC：代表了CPU每个时钟周期完成（retired）的指令数目。现代处理器的指令运行都是流水线（pipeline）的形式，每个（汇编）指令可分为取指、译码、执行等多条指令（uOPs），通过并行这些指令可以实现大于1的IPC。\n\n> Instructions Retired per Cycle, or IPC shows average number of retired instructions per cycle. Modern superscalar processors issue up to four instructions per cycle, suggesting a theoretical best IPC of 4. But various effects (long-latency memory, floating-point, or SIMD operations; non-retired instructions due to branch mispredictions; instruction starvation in the front-end) tend to pull the observed IPC down. A IPC > 1 is typical for instruction bound code, while a IPC < 1 may show up for a stall cycle bound application, also likely memory bound. IPC is an excellent metric for judging an overall potential for application performance tuning.\n\nRetiring：在CPU的指令控制单元（Instruction Control Unit）中，retirement unit记录正在进行的处理。一旦一条指令的操作完成了，而且所有引起这条指令的分支点也都被确认为预测正确，那么这条指令就可以retired了。Retiring的值越高，说明指令的利用率越高。\n\n> Retiring metric represents a Pipeline Slots fraction utilized by useful work, meaning the issued uOps that eventually get retired. Ideally, all Pipeline Slots would be attributed to the Retiring category. Retiring of 100% would indicate the maximum possible number of uOps retired per cycle has been achieved. Maximizing Retiring typically increases the Instruction-Per-Cycle metric. Note that a high Retiring value does not necessary mean no more room for performance improvement. For example, Microcode assists are categorized under Retiring. They hurt performance and can often be avoided.\n\nVectorization：代表向量化指令的占比（vaddps, ...）。\n\n> This metric represents the percentage of packed (vectorized) floating point operations. 0% means that the code is fully scalar. The metric does not take into account the actual vector length that was used by the code for vector instructions. So if the code is fully vectorized and uses a legacy instruction set that loaded only half a vector length, the Vectorization metric shows 100%.\n\n\n### Hotspot\n\n通过hotspot可以让我们从多个角度去分析程序不同位置的时间消耗，包括：\n\n1. top down\n2. caller\n3. bottom up\n4. flame graph\n5. ...\n\n通过点击相应的函数你可以直接看到对应的代码行的占用时间，以及对应的汇编代码（如下图）\n\n![](/img/20221121215137.png)  \n\n\n有时候，你会发现你所需要分析的代码仅仅只是庞大代码中的一小部分，这时候该怎么办？[Instrumentation and Tracing Technology API](https://www.intel.com/content/www/us/en/develop/documentation/gpa-user-guide/top/instrumentation-and-tracing-technology-apis.html)提供了相应的解决方案。\n\n\n## 结论\n\n通过vtune我们可以很清晰的了解到每个函数，特定行的时间占比，通过top down的Performance Snapshote，可以帮助我们从较高维度理解程序性能，为之后的优化指明方向。\n\n\n## 参考\n\n[CPU Metrics Reference](https://www.intel.com/content/www/us/en/develop/documentation/vtune-help/top/reference/cpu-metrics-reference.html#cpu-metrics-reference_PIPELINE-SLOTS)\n",
    "code": "var Component=(()=>{var p=Object.create;var i=Object.defineProperty;var m=Object.getOwnPropertyDescriptor;var u=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var N=(a,e)=>()=>(e||a((e={exports:{}}).exports,e),e.exports),k=(a,e)=>{for(var t in e)i(a,t,{get:e[t],enumerable:!0})},r=(a,e,t,c)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of u(e))!f.call(a,s)&&s!==t&&i(a,s,{get:()=>e[s],enumerable:!(c=m(e,s))||c.enumerable});return a};var y=(a,e,t)=>(t=a!=null?p(g(a)):{},r(e||!a||!a.__esModule?i(t,\"default\",{value:a,enumerable:!0}):t,a)),b=a=>r(i({},\"__esModule\",{value:!0}),a);var l=N((P,o)=>{o.exports=_jsx_runtime});var w={};k(w,{default:()=>h,frontmatter:()=>v});var n=y(l()),v={title:\"Vtune Usage\",date:\"2022-11-21\",tags:[\"profiling\",\"Intel\",\"VTune\"],draft:!1,summary:\"Instructions Retired per Cycle, or IPC shows average number of retired instructions per cycle. Modern superscalar processors issue up to four instruct\",authors:[\"default\"]};function d(a){let e={a:\"a\",blockquote:\"blockquote\",code:\"code\",h2:\"h2\",h3:\"h3\",img:\"img\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",span:\"span\",...a.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.h2,{id:\"\\u524D\\u8A00\",className:\"content-header\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#\\u524D\\u8A00\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"\\u524D\\u8A00\"]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u6700\\u8FD1\\u5728\\u7814\\u7A76vtune\\uFF0C\\u8BD5\\u7740\\u7528\\u5176\\u8FDB\\u884C\\u4EE3\\u7801\\u6027\\u80FD\\u7684\\u5206\\u6790\\uFF0C\\u4E3B\\u8981\\u770B\\u4E86snapshot\\u548Chotspot\\u4E24\\u4E2Aanalysis type\\u3002\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"vtune\\u7684\\u5B89\\u88C5\\u53EF\\u4EE5\\u4F7F\\u7528\\u5B98\\u65B9\\u7684docker\\uFF0C\\u6216\\u8005\",(0,n.jsx)(e.a,{href:\"https://www.intel.com/content/www/us/en/develop/documentation/installation-guide-for-intel-oneapi-toolkits-linux/top.html\",children:\"\\u81EA\\u5DF1\\u5B89\\u88C5oneAPI\"}),\"\\u3002\\u6211\\u4F7F\\u7528\\u7684\\u662F\",(0,n.jsx)(e.a,{href:\"https://www.intel.com/content/www/us/en/develop/documentation/installation-guide-for-intel-oneapi-toolkits-linux/top/installation/install-using-package-managers/apt.html\",children:\"apt install\"}),\"\\uFF0C\\u811A\\u672C\\u5982\\u4E0B\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{className:\"language-bash\",children:(0,n.jsxs)(e.code,{className:\"language-bash code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token function\",children:\"apt-get\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"install\"}),\" \",(0,n.jsx)(e.span,{className:\"token parameter variable\",children:\"-y\"}),\" --no-install-recommends \",(0,n.jsx)(e.span,{className:\"token function\",children:\"curl\"}),` ca-certificates gpg-agent software-properties-common\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"# download the key to system keyring\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token function\",children:\"wget\"}),\" -O- https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB \",(0,n.jsx)(e.span,{className:\"token operator\",children:\"|\"}),\" gpg \",(0,n.jsx)(e.span,{className:\"token parameter variable\",children:\"--dearmor\"}),\" \",(0,n.jsx)(e.span,{className:\"token operator\",children:\"|\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"tee\"}),\" /usr/share/keyrings/oneapi-archive-keyring.gpg \",(0,n.jsx)(e.span,{className:\"token operator\",children:\">\"}),` /dev/null\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"# add signed entry to apt sources and configure the APT client to use Intel repository:\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token builtin class-name\",children:\"echo\"}),\" \",(0,n.jsx)(e.span,{className:\"token string\",children:'\"deb [signed-by=/usr/share/keyrings/oneapi-archive-keyring.gpg] https://apt.repos.intel.com/oneapi all main\"'}),\" \",(0,n.jsx)(e.span,{className:\"token operator\",children:\"|\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"tee\"}),` /etc/apt/sources.list.d/oneAPI.list\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"# install base kit and hpc kit\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token function\",children:\"apt\"}),\" update \",(0,n.jsx)(e.span,{className:\"token operator\",children:\"&&\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"apt\"}),\" \",(0,n.jsx)(e.span,{className:\"token function\",children:\"install\"}),\" intel-basekit intel-hpckit \",(0,n.jsx)(e.span,{className:\"token parameter variable\",children:\"-y\"}),`\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:`\n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"# source vtune env\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token builtin class-name\",children:\"echo\"}),\" \",(0,n.jsx)(e.span,{className:\"token string\",children:'\"source /opt/intel/oneapi/vtune/latest/vtune-vars.sh\"'}),\" \",(0,n.jsx)(e.span,{className:\"token operator\",children:\">>\"}),` ~/.bashrc\n`]})]})}),`\n`,(0,n.jsxs)(e.h2,{id:\"\\u7528\\u6CD5\",className:\"content-header\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#\\u7528\\u6CD5\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"\\u7528\\u6CD5\"]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u56E0\\u4E3A\\u4EE3\\u7801\\u8FD0\\u884C\\u5F80\\u5F80\\u5728\\u8FDC\\u7A0B\\u670D\\u52A1\\u5668\\u4E0A\\uFF0C\\u4E00\\u822C\\u6765\\u8BF4\\u662F\\u6CA1\\u6709GUI\\u7684\\uFF0C\\u56E0\\u6B64\\u6211\\u4EEC\\u91C7\\u53D6\\u7684\\u65B9\\u5F0F\\u662F\\u5728\\u8FDC\\u7AEF\\u6211\\u4EEC\\u4F7F\\u7528CLI\\u8FDB\\u884C\\u5206\\u6790\\uFF0C\\u5C06\\u5206\\u6790\\u7ED3\\u679C\\u5728\\u672C\\u5730\\u673A\\u5668\\u4E0A\\u53EF\\u89C6\\u5316\\u3002\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u547D\\u4EE4\\u53EF\\u4EE5\\u7528\",(0,n.jsx)(e.code,{children:\"vtune -h\"}),\"\\u67E5\\u770B\\uFF1A\"]}),`\n`,(0,n.jsx)(e.pre,{className:\"language-bash\",children:(0,n.jsxs)(e.code,{className:\"language-bash code-highlight\",children:[(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"#  1) Start with a performance snapshot. Get a quick overview of potential performance issues. Identify next steps for a deeper analysis:\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"vtune \",(0,n.jsx)(e.span,{className:\"token parameter variable\",children:\"-collect\"}),` performance-snapshot a.out\n`]}),(0,n.jsx)(e.span,{className:\"code-line\",children:` \n`}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[(0,n.jsx)(e.span,{className:\"token comment\",children:\"#  2) Run a hotspots collection (in user-mode sampling) on the specified target:\"}),`\n`]}),(0,n.jsxs)(e.span,{className:\"code-line\",children:[\"vtune \",(0,n.jsx)(e.span,{className:\"token parameter variable\",children:\"-collect\"}),` hotspots a.out\n`]})]})}),`\n`,(0,n.jsxs)(e.h3,{id:\"performance-snapshot\",className:\"content-header\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#performance-snapshot\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Performance Snapshot\"]}),`\n`,(0,n.jsx)(e.p,{children:\"IPC\\uFF1A\\u4EE3\\u8868\\u4E86CPU\\u6BCF\\u4E2A\\u65F6\\u949F\\u5468\\u671F\\u5B8C\\u6210\\uFF08retired\\uFF09\\u7684\\u6307\\u4EE4\\u6570\\u76EE\\u3002\\u73B0\\u4EE3\\u5904\\u7406\\u5668\\u7684\\u6307\\u4EE4\\u8FD0\\u884C\\u90FD\\u662F\\u6D41\\u6C34\\u7EBF\\uFF08pipeline\\uFF09\\u7684\\u5F62\\u5F0F\\uFF0C\\u6BCF\\u4E2A\\uFF08\\u6C47\\u7F16\\uFF09\\u6307\\u4EE4\\u53EF\\u5206\\u4E3A\\u53D6\\u6307\\u3001\\u8BD1\\u7801\\u3001\\u6267\\u884C\\u7B49\\u591A\\u6761\\u6307\\u4EE4\\uFF08uOPs\\uFF09\\uFF0C\\u901A\\u8FC7\\u5E76\\u884C\\u8FD9\\u4E9B\\u6307\\u4EE4\\u53EF\\u4EE5\\u5B9E\\u73B0\\u5927\\u4E8E1\\u7684IPC\\u3002\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Instructions Retired per Cycle, or IPC shows average number of retired instructions per cycle. Modern superscalar processors issue up to four instructions per cycle, suggesting a theoretical best IPC of 4. But various effects (long-latency memory, floating-point, or SIMD operations; non-retired instructions due to branch mispredictions; instruction starvation in the front-end) tend to pull the observed IPC down. A IPC > 1 is typical for instruction bound code, while a IPC < 1 may show up for a stall cycle bound application, also likely memory bound. IPC is an excellent metric for judging an overall potential for application performance tuning.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Retiring\\uFF1A\\u5728CPU\\u7684\\u6307\\u4EE4\\u63A7\\u5236\\u5355\\u5143\\uFF08Instruction Control Unit\\uFF09\\u4E2D\\uFF0Cretirement unit\\u8BB0\\u5F55\\u6B63\\u5728\\u8FDB\\u884C\\u7684\\u5904\\u7406\\u3002\\u4E00\\u65E6\\u4E00\\u6761\\u6307\\u4EE4\\u7684\\u64CD\\u4F5C\\u5B8C\\u6210\\u4E86\\uFF0C\\u800C\\u4E14\\u6240\\u6709\\u5F15\\u8D77\\u8FD9\\u6761\\u6307\\u4EE4\\u7684\\u5206\\u652F\\u70B9\\u4E5F\\u90FD\\u88AB\\u786E\\u8BA4\\u4E3A\\u9884\\u6D4B\\u6B63\\u786E\\uFF0C\\u90A3\\u4E48\\u8FD9\\u6761\\u6307\\u4EE4\\u5C31\\u53EF\\u4EE5retired\\u4E86\\u3002Retiring\\u7684\\u503C\\u8D8A\\u9AD8\\uFF0C\\u8BF4\\u660E\\u6307\\u4EE4\\u7684\\u5229\\u7528\\u7387\\u8D8A\\u9AD8\\u3002\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"Retiring metric represents a Pipeline Slots fraction utilized by useful work, meaning the issued uOps that eventually get retired. Ideally, all Pipeline Slots would be attributed to the Retiring category. Retiring of 100% would indicate the maximum possible number of uOps retired per cycle has been achieved. Maximizing Retiring typically increases the Instruction-Per-Cycle metric. Note that a high Retiring value does not necessary mean no more room for performance improvement. For example, Microcode assists are categorized under Retiring. They hurt performance and can often be avoided.\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"Vectorization\\uFF1A\\u4EE3\\u8868\\u5411\\u91CF\\u5316\\u6307\\u4EE4\\u7684\\u5360\\u6BD4\\uFF08vaddps, ...\\uFF09\\u3002\"}),`\n`,(0,n.jsxs)(e.blockquote,{children:[`\n`,(0,n.jsx)(e.p,{children:\"This metric represents the percentage of packed (vectorized) floating point operations. 0% means that the code is fully scalar. The metric does not take into account the actual vector length that was used by the code for vector instructions. So if the code is fully vectorized and uses a legacy instruction set that loaded only half a vector length, the Vectorization metric shows 100%.\"}),`\n`]}),`\n`,(0,n.jsxs)(e.h3,{id:\"hotspot\",className:\"content-header\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#hotspot\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"Hotspot\"]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u901A\\u8FC7hotspot\\u53EF\\u4EE5\\u8BA9\\u6211\\u4EEC\\u4ECE\\u591A\\u4E2A\\u89D2\\u5EA6\\u53BB\\u5206\\u6790\\u7A0B\\u5E8F\\u4E0D\\u540C\\u4F4D\\u7F6E\\u7684\\u65F6\\u95F4\\u6D88\\u8017\\uFF0C\\u5305\\u62EC\\uFF1A\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"top down\"}),`\n`,(0,n.jsx)(e.li,{children:\"caller\"}),`\n`,(0,n.jsx)(e.li,{children:\"bottom up\"}),`\n`,(0,n.jsx)(e.li,{children:\"flame graph\"}),`\n`,(0,n.jsx)(e.li,{children:\"...\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u901A\\u8FC7\\u70B9\\u51FB\\u76F8\\u5E94\\u7684\\u51FD\\u6570\\u4F60\\u53EF\\u4EE5\\u76F4\\u63A5\\u770B\\u5230\\u5BF9\\u5E94\\u7684\\u4EE3\\u7801\\u884C\\u7684\\u5360\\u7528\\u65F6\\u95F4\\uFF0C\\u4EE5\\u53CA\\u5BF9\\u5E94\\u7684\\u6C47\\u7F16\\u4EE3\\u7801\\uFF08\\u5982\\u4E0B\\u56FE\\uFF09\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.img,{src:\"/img/20221121215137.png\",alt:\"\"})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u6709\\u65F6\\u5019\\uFF0C\\u4F60\\u4F1A\\u53D1\\u73B0\\u4F60\\u6240\\u9700\\u8981\\u5206\\u6790\\u7684\\u4EE3\\u7801\\u4EC5\\u4EC5\\u53EA\\u662F\\u5E9E\\u5927\\u4EE3\\u7801\\u4E2D\\u7684\\u4E00\\u5C0F\\u90E8\\u5206\\uFF0C\\u8FD9\\u65F6\\u5019\\u8BE5\\u600E\\u4E48\\u529E\\uFF1F\",(0,n.jsx)(e.a,{href:\"https://www.intel.com/content/www/us/en/develop/documentation/gpa-user-guide/top/instrumentation-and-tracing-technology-apis.html\",children:\"Instrumentation and Tracing Technology API\"}),\"\\u63D0\\u4F9B\\u4E86\\u76F8\\u5E94\\u7684\\u89E3\\u51B3\\u65B9\\u6848\\u3002\"]}),`\n`,(0,n.jsxs)(e.h2,{id:\"\\u7ED3\\u8BBA\",className:\"content-header\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#\\u7ED3\\u8BBA\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"\\u7ED3\\u8BBA\"]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u901A\\u8FC7vtune\\u6211\\u4EEC\\u53EF\\u4EE5\\u5F88\\u6E05\\u6670\\u7684\\u4E86\\u89E3\\u5230\\u6BCF\\u4E2A\\u51FD\\u6570\\uFF0C\\u7279\\u5B9A\\u884C\\u7684\\u65F6\\u95F4\\u5360\\u6BD4\\uFF0C\\u901A\\u8FC7top down\\u7684Performance Snapshote\\uFF0C\\u53EF\\u4EE5\\u5E2E\\u52A9\\u6211\\u4EEC\\u4ECE\\u8F83\\u9AD8\\u7EF4\\u5EA6\\u7406\\u89E3\\u7A0B\\u5E8F\\u6027\\u80FD\\uFF0C\\u4E3A\\u4E4B\\u540E\\u7684\\u4F18\\u5316\\u6307\\u660E\\u65B9\\u5411\\u3002\"}),`\n`,(0,n.jsxs)(e.h2,{id:\"\\u53C2\\u8003\",className:\"content-header\",children:[(0,n.jsx)(e.a,{\"aria-hidden\":\"true\",tabIndex:\"-1\",href:\"#\\u53C2\\u8003\",children:(0,n.jsx)(e.span,{className:\"icon icon-link\"})}),\"\\u53C2\\u8003\"]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.a,{href:\"https://www.intel.com/content/www/us/en/develop/documentation/vtune-help/top/reference/cpu-metrics-reference.html#cpu-metrics-reference_PIPELINE-SLOTS\",children:\"CPU Metrics Reference\"})})]})}function h(a={}){let{wrapper:e}=a.components||{};return e?(0,n.jsx)(e,{...a,children:(0,n.jsx)(d,{...a})}):d(a)}return b(w);})();\n;return Component;"
  },
  "_id": "blog/Systems/vtune-intro.md",
  "_raw": {
    "sourceFilePath": "blog/Systems/vtune-intro.md",
    "sourceFileName": "vtune-intro.md",
    "sourceFileDir": "blog/Systems",
    "contentType": "markdown",
    "flattenedPath": "blog/Systems/vtune-intro"
  },
  "type": "Blog",
  "readingTime": {
    "text": "5 min read",
    "minutes": 4.455,
    "time": 267300,
    "words": 891
  },
  "slug": "vtune-intro",
  "path": "blog/Systems/vtune-intro",
  "toc": [
    {
      "value": "前言",
      "url": "#前言",
      "depth": 2
    },
    {
      "value": "用法",
      "url": "#用法",
      "depth": 2
    },
    {
      "value": "Performance Snapshot",
      "url": "#performance-snapshot",
      "depth": 3
    },
    {
      "value": "Hotspot",
      "url": "#hotspot",
      "depth": 3
    },
    {
      "value": "结论",
      "url": "#结论",
      "depth": 2
    },
    {
      "value": "参考",
      "url": "#参考",
      "depth": 2
    }
  ],
  "structuredData": {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "Vtune Usage",
    "datePublished": "2022-11-21T00:00:00.000Z",
    "dateModified": "2022-11-21T00:00:00.000Z",
    "description": "Instructions Retired per Cycle, or IPC shows average number of retired instructions per cycle. Modern superscalar processors issue up to four instruct",
    "url": "https://zhangjian94cn.github.io/blog/vtune-intro"
  }
}